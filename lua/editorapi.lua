local M = {}

-- editorapi is used to determine state and integration for the editor
vim.api.nvim_create_user_command("EditorDebug", function()
    M.print_state()
end, {})

-- ENUMS

M.tabt = {
    INVALID = 0xff00,
    EDIT = 0x0100,     -- MainEdit: NvimTree and 1 or 2 opened file buffers
    AI_DIFF = 0x0200,   -- AiDiff:   Viewing diff generated by AI in a different tabpage
    DIFF = 0x0300,     -- MainDiff: Viewing diff explorer and 2 or 3 way diff
}

M.wint = {
    INVALID = 0xff00,
    NTREE = 0x0101,     -- NvimTree
    NFILE = 0x0102,     -- Normal File
    NTERM = 0x0103,     -- Normal Terminal
    NOTIF = 0x0110,     -- Notification Window
    FLOAT = 0x0111,     -- Floating Window
    TELES = 0x0112,     -- Telescope
    AIFILE = 0x0201,    -- Original file in AI Diff
    AIDIFF = 0x0202,    -- Proposed change in AI Diff
    DTREE = 0x0301,     -- Tree in diff view
    DFILE = 0x0302,     -- In diff view, the file (not sure how to detect "old" vs "new", should be a way)
}
local wint2tabt = function(wint) return bit.band(wint, 0xff00) end

local function enumname(value)
    for name, v in pairs(M.wint) do
        if v == value then return name end
    end
    for name, v in pairs(M.tabt) do
        if v == value then return name end
    end
    return tostring(value)
end

-- AUTOCOMMANDS

-- STATES
-- making editorapi stateful for better performance. for example,
-- avoids recomputing window types and tabpage types

M.s_tabts = {} -- tabpage id -> tabt
M.s_tabmp = {} -- tabt -> tagpage id
M.s_wints = {} -- window id -> wint
function M.print_state()
    local tabts_str = {}
    for tabid, tabt in pairs(M.s_tabts) do
        tabts_str[tabid] = enumname(tabt)
    end
    local tabmp_str = {}
    for tabt, tabid in pairs(M.s_tabmp) do
        tabmp_str[enumname(tabt)] = tabid
    end
    local wints_str = {}
    for winid, wint in pairs(M.s_wints) do
        wints_str[winid] = enumname(wint)
    end
    local msg = "s_tabts=" .. vim.inspect(tabts_str) .. "\ns_tabmp="..vim.inspect(tabmp_str).."\ns_wints="..vim.inspect(wints_str)
    vim.api.nvim_echo({{ msg, "Normal" }}, true, {})
end

local wints_ops = 0
function M.clean_state(force)
    if wints_ops < 100 and not force then
        return
    end
    wints_ops = 0
    local to_remove = {}
    for tabid, _ in pairs(M.s_tabts) do
        if not vim.api.nvim_tabpage_is_valid(tabid) then
            table.insert(to_remove, tabid)
        end
    end
    for _, tabid in ipairs(to_remove) do
        M.s_tabts[tabid] = nil
    end
    if #to_remove > 0 then
        M.s_tabmp = {}
        for tabid, tabt in pairs(M.s_tabts) do
            M.s_tabmp[tabt] = tabid
        end
    end
    to_remove = {}
    for winid, _ in pairs(M.s_wints) do
        if not vim.api.nvim_win_is_valid(winid) then
            table.insert(to_remove, winid)
        end
    end
    for _, winid in ipairs(to_remove) do
        M.s_wints[winid] = nil
    end
end

---Get the tabpage id if exists, or nil
function M.query_tabid(tabt)
    local tabid = M.s_tabmp[tabt]
    if tabid ~= nil then
        local t = M.query_tabt(tabid)
        if t == tabt then
            return tabid
        end
        M.s_tabmp[tabt] = nil
    end
    for _, tabid2 in ipairs(vim.api.nvim_list_tabpages()) do
        local t = M.query_tabt(tabid2)
        if t ~= M.tabt.INVALID then
            M.s_tabmp[t] = tabid2
        end
    end
    return M.s_tabmp[tabt]
end

---Get the type of a window
---@param winid integer | nil window id
function M.query_wint(winid)
    if winid == 0 or winid == nil then
        winid = vim.api.nvim_get_current_win()
    else
        if not vim.api.nvim_win_is_valid(winid) then
            M.s_wints[winid] = nil
            return M.wint.INVALID
        end
    end
    local w = M.s_wints[winid]
    if w ~= nil then -- previous queried, assume it's still valid
        return w
    end
    w = M.calc_wint(winid)
    M.s_wints[winid] = w
    wints_ops = wints_ops + 1
    M.clean_state(false)
    return w
end

---Calculate type of window
---@param winid integer valid window id
function M.calc_wint(winid)
    local fast_wint = M.calc_wint_fast(winid)
    if fast_wint ~= M.wint.INVALID then return fast_wint end

    local tabid = vim.api.nvim_win_get_tabpage(winid)
    local tabtype = M.query_tabt(tabid)
    if tabtype == M.tabt.EDIT    then return M.wint.NFILE end
    if tabtype == M.tabt.AI_DIFF then return M.wint.AIFILE end
    return M.wint.DFILE
end

---Get the type of a tabpage
---@param tabid integer | nil tabpage id
function M.query_tabt(tabid)
    if tabid == 0 or tabid == nil then
        tabid = vim.api.nvim_get_current_tabpage()
    else
        if not vim.api.nvim_tabpage_is_valid(tabid) then
            M.s_tabmp[M.s_tabts[tabid]] = nil
            M.s_tabts[tabid] = nil
            -- default to edit
            return M.tabt.EDIT
        end
    end
    local x = M.s_tabts[tabid]
    if x ~= nil then -- previous queried, assume it's still valid
        return x
    end
    x = M.calc_tabt(tabid)
    M.s_tabts[tabid] = x
    M.s_tabmp[x] = tabid
    return x
end

---Calculate type of tabpage
---@param tabid integer valid tabpage id
function M.calc_tabt(tabid)
    for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid)) do
        local fast_wint = M.calc_wint_fast(winid)
        if fast_wint ~= M.wint.INVALID then return wint2tabt(fast_wint) end
    end
    -- default to edit view (for example, editing single file)
    return M.tabt.EDIT
end

function M.calc_wint_fast(winid)
    local bufnr = vim.api.nvim_win_get_buf(winid)

    local filetype = vim.bo[bufnr].filetype
    if filetype == "NvimTree"          then return M.wint.NTREE end
    if filetype == "codediff-explorer" then return M.wint.DTREE end
    if filetype == "claude-notify"     then return M.wint.NOTIF end
    if filetype == "floaterm"          then return M.wint.FLOAT end

    local buftype = vim.bo[bufnr].buftype
    if buftype == "terminal"           then return M.wint.NTERM end
    if string.find(filetype, "Telescope") then
        return M.wint.TELES
    end
    local bufname = vim.api.nvim_buf_get_name(bufnr)
    if bufname:match("%.claude%-proposed") ~= nil then
        return M.wint.AIDIFF
    end

    return M.wint.INVALID
end

---Check if currently focused on aicoder (in the right buffer and terminal mode)
function M.is_aicoder_focused()
    if vim.api.nvim_get_mode().mode == "t" then
        if M.buftyp() == M.buft.FILETERM then
            return true
        end
    end
    return false
end

-- VIEW CHANGE =====================================================================

---Swap the 2 files in edit view
function M.editview_swap_files()
    local tabt = M.query_tabt()
    if tabt ~= M.tabt.EDIT then return end
    if vim.bo.buftype == "terminal" then return end -- faster query

    local filewins, _ = M.editview_query_file_windows()
    if #filewins ~= 2 then return end
    -- must use win_splitmove, otherwise it will not work
    -- if both windows have the same buffer
    local x_1 = vim.api.nvim_win_get_position(filewins[1])[2]
    local x_2 = vim.api.nvim_win_get_position(filewins[2])[2]
    local win_left, win_right
    if x_1 < x_2 then
        win_left = filewins[1]
        win_right = filewins[2]
    else
        win_left = filewins[2]
        win_right = filewins[1]
    end
    vim.fn.win_splitmove(win_right, win_left, { vertical = true })
end

---Duplicate the focused view in edit view
---@param right boolean if true, end up in the right window
function M.editview_duplicate(right)
    local tabt = M.query_tabt()
    if tabt ~= M.tabt.EDIT then M.warn("here1") return end
    if vim.bo.buftype == "terminal" then M.warn("here2") return end -- faster query

    local filewins, termwins = M.editview_query_file_windows()
    for _, winid in ipairs(termwins) do
        vim.api.nvim_win_hide(winid)
    end
    local windows_len = #filewins
    if windows_len == 1 then
        local curr_winid = vim.api.nvim_get_current_win()
        if curr_winid ~= filewins[1] then
            vim.api.nvim_set_current_win(filewins[1])
        end
        if right then vim.api.nvim_input('<C-w>v<C-W>l') else vim.api.nvim_input('<C-w>v') end
        M.warn("here3")
        return
    end
    if windows_len == 2 then
        -- we don't use split here to avoid motion sickness
        local curr_winid = vim.api.nvim_get_current_win()
        local other_winid
        if curr_winid == filewins[1] then
            other_winid = filewins[2]
        elseif curr_winid == filewins[2] then
            other_winid = filewins[1]
        else
            return
        end
        local bufnr = vim.api.nvim_win_get_buf(curr_winid)
        local cursor = vim.api.nvim_win_get_cursor(curr_winid)
        local screenrow = vim.fn.screenpos(curr_winid, cursor[1], cursor[2]).row
        local height = vim.api.nvim_win_get_height(other_winid)

        local new_cursor_row_for_view = cursor[1] - screenrow + math.floor((height+1)/2)
        local bufnr_lc = vim.api.nvim_buf_line_count(bufnr)
        local need_fallback_view = new_cursor_row_for_view > bufnr_lc

        local x_1 = vim.api.nvim_win_get_position(curr_winid)[2]
        local x_2 = vim.api.nvim_win_get_position(other_winid)[2]
        local need_focus = (x_1 < x_2) == right

        vim.api.nvim_win_set_buf(other_winid, bufnr)
        if need_fallback_view then
            vim.api.nvim_win_set_cursor(other_winid, cursor)
        else
            vim.api.nvim_win_set_cursor(other_winid, { new_cursor_row_for_view, cursor[2] })
            vim.fn.win_execute(other_winid, "normal! zz")
            vim.api.nvim_win_set_cursor(other_winid, cursor)
        end
        if need_focus then
            vim.api.nvim_set_current_win(other_winid)
        end
    end
end

---If in floaterm, close floaterm
---Otherwise switch to EDIT and show floaterm
function M.editview_floaterm_toggle()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd.FloatermToggle()
        return
    end
    local tabid = M.query_tabid(M.tabt.EDIT)
    if tabid == vim.api.nvim_get_current_tabpage() then -- if we are on edit view then toggle terminal
        vim.cmd.FloatermToggle()
        return
    end
    -- switch to edit view and show/focus on terminal
    vim.api.nvim_set_current_tabpage(tabid)
    wint = M.query_wint()
    if wint == M.wint.FLOAT then -- already focused
        return
    end
    for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid)) do
        wint = M.query_wint(winid)
        if wint == M.wint.FLOAT then
            local curr_winid = vim.api.nvim_get_current_win()
            if curr_winid ~= winid then
                vim.api.nvim_set_current_win(curr_winid)
                return
            end
        end
    end
    -- did not find floaterm, toggle it
    vim.cmd.FloatermToggle()
end


---If in floaterm, make a new terminal instance
function M.editview_floaterm_new()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd.FloatermNew()
    end
end

---If in floaterm, cycle between the terminals
function M.editview_floaterm_cycle()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd.FloatermNext()
    end
end

---Action to escape active terminal
---If in NTERM, it will ready to switch focus
---If in FLOAT, it will switch to normal mode
function M.editview_terminal_escape()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd("stopinsert")
        return
    end
    if wint == M.wint.NTERM then
        vim.cmd("stopinsert")
        -- also execute another C-w to be ready to switch focus
        vim.api.nvim_input("<C-w>")
    end
end


-- VIEW CHANGE / Telescope =====================================================================

---Switch to tab based on type, execute the callback if succeeded
---return true if switch successful
function M.switch_tab_then(tab_type, cb)
    local tabpages = M.query_tabpages()
    local tabpage = tabpages[tab_type]
    if tabpage == nil then
        M.warn("cannot find requested tabpage")
        return false
    end
    local current = vim.api.nvim_get_current_tabpage()
    if current == tabpage then
        if cb then cb() end
    else
        vim.api.nvim_set_current_tabpage(tabpage)
        if cb then vim.defer_fn(cb, 30) end
    end
    return true
end

--- (Only available in EDIT tab) Focus the window that's on (close the other), then call CB
function M.editview_focus_then(cb)
    local tt, bt = M.viewtyp()
    if tt ~= M.tabt.EDIT or bt == M.buft.FILETERM or bt == M.buft.TREE then
        M.warn("operation not supported on current window")
        return
    end
    local window = vim.api.nvim_get_current_win();
    for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(0)) do
        if winid ~= window then
            local bufnr = vim.api.nvim_win_get_buf(winid)
            if M.buftyp(bufnr) ~= M.buft.NOTIF then
                vim.api.nvim_win_hide(winid)
            end
        end
    end
    vim.cmd.NvimTreeOpen()
    vim.api.nvim_input("<C-w>l")
    vim.defer_fn(cb, 30)
end

function M.switch_to_editview_then(cb)
    M.switch_tab_then(M.tabt.EDIT, function()
        local bt = M.buftyp()
        if bt == M.buft.FILETERM then
            -- switch focus to other view
            vim.cmd("stopinsert")
            vim.api.nvim_input("<C-w>h")
            if cb then vim.defer_fn(cb, 30) end
            return
        end
        if bt == M.buft.FLOATERM then
            vim.cmd.FloatermToggle()
            if cb then vim.defer_fn(cb, 30) end
            return
        end
        if cb then cb() end
    end)
end

function M.open_file_finder()
    M.switch_to_editview_then(function()
        local builtin = require('telescope.builtin')
        builtin.find_files {
            attach_mappings = function(bufnr, map)
                map("i", "<C-l>", function()
                    local actions = require "telescope.actions"
                    actions.close(bufnr)
                    vim.defer_fn(function()
                        local action_state = require "telescope.actions.state"
                        local selection = action_state.get_selected_entry()
                        vim.cmd("ClaudeCodeAdd " .. selection[1])
                        -- keep focus inside fileterm
                        vim.api.nvim_input("<C-w>l")
                    end, 100)
                end)
                -- needs to return true to map default_mappings
                return true
            end
        }
    end)
end

function M.open_last_finder()
    M.switch_to_editview_then(function() vim.cmd("Telescope resume") end)
end

function M.open_live_grep_finder()
    M.switch_to_editview_then(function() require("telescope.builtin").live_grep() end)
end

function M.open_buffer_finder()
    M.switch_to_editview_then(function() require("telescope.builtin").buffers() end)
end

function M.open_definition_finder()
    M.switch_to_editview_then(function() require("telescope.builtin").lsp_definitions() end)
end

function M.open_reference_finder()
    M.switch_to_editview_then(function() require("telescope.builtin").lsp_references() end)
end

function M.open_implementation_finder()
    M.switch_to_editview_then(function() require("telescope.builtin").lsp_implementations() end)
end

---View diagnostics of current buffer
function M.open_diagnostic_finder()
    M.switch_to_editview_then(function() require("telescope.builtin").diagnostics({ bufnr = 0 }) end)
end

function M.open_symbol_finder()
    M.switch_to_editview_then(function() require("telescope.builtin").treesitter() end)
end

local aicoder_started = false

---List NFILE window ids in the edit view
---@param tabid integer | nil, the EDIT tabid, 0 to use current tab
function M.editview_query_file_windows(tabid)
    local files = {}
    local terms = {}
    for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid or 0)) do
        local wint = M.query_wint(winid)
        if wint == M.wint.NFILE then
            table.insert(files, winid)
        elseif wint == M.wint.NTERM then
            table.insert(terms, winid)
        end
    end
    return files, terms
end

---Switch to EDIT and open AI Coder
function M.open_aicoder()
    if not aicoder_started then
        vim.cmd.ClaudeCodeStart()
        aicoder_started = true
    end
    local do_open_aicoder = function()
        M.editview_focus_then(function()
            vim.cmd.ClaudeCode()
        end)
    end

    M.switch_tab_then(M.tabt.EDIT, function()
        local bt = M.buftyp()
        if bt == M.buft.FILETERM then
            -- already in
            vim.cmd("startinsert")
            return
        end
        if bt == M.buft.FLOATERM then
            vim.cmd.FloatermToggle()
            vim.defer_fn(do_open_aicoder, 30)
            return
        end
        do_open_aicoder()
    end)
end

---Close AI Coder UI when in EDIT view
---Or close AI Coder Diff when in AIDiff view
function M.close_aicoder()
    -- local tt = M.tabtyp()
    -- if tt == M.tabt.EDIT then
    --     for _, winid in ipairs(vim.api.nvim_list_wins()) do
    --         local bufnr = vim.api.nvim_win_get_buf(winid)
    --         if M.buftyp(bufnr) == M.buft.FILETERM then
    --             vim.api.nvim_win_hide(winid)
    --         end
    --     end
    --     vim.cmd.ClaudeCodeNotificationDismiss()
    --     return
    -- end
    -- if tt == M.tabt.AIDIFF then
    --     vim.cmd.CodeDiff()
    --     vim.defer_fn(function()
    --         M.switch_to_editview_then(nil)
    --     end, 30)
    --     return
    -- end
end

M.was_aicoder_focused_when_aidiff_open = false
M.just_accepted_aidiff = false

---If not looking at AIDiff, open it
---Otherwise accept it
function M.open_or_accept_aidiff()
    local tt = M.tabtyp()
    if tt == M.tabt.AIDIFF then
        local should_focus = M.was_aicoder_focused_when_aidiff_open
        -- already looking at diff, accept it
        -- make sure no unsaved modifications in all opened windows
        for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(0)) do
            local bufnr = vim.api.nvim_win_get_buf(winid)
            local buft = M.buftyp(bufnr)
            if buft == M.buft.AIDIFF or buft == M.buft.AIFILE then
                if vim.bo[bufnr].modified then
                    M.warn("diff is unsaved, must save before accepting")
                    return
                end
            end
        end
        local curr_tabpage = vim.api.nvim_get_current_tabpage()
        M.just_accepted_aidiff = true
        vim.cmd.ClaudeCodeDiffAccept()
        M.switch_to_editview_then(function()
            -- close the aidiff
            vim.cmd(vim.api.nvim_tabpage_get_number(curr_tabpage) .. "tabclose")
            M.switch_to_editview_then(function()
                -- close any dangling aidiff buffers if needed
                for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
                    if M.buftyp(bufnr) == M.buft.AIDIFF then
                        vim.api.nvim_buf_delete(bufnr, {force=false})
                    end
                end
                if should_focus then
                    vim.defer_fn(function()
                        if M.tabtyp() == M.tabt.EDIT then
                            vim.cmd.ClaudeCodeFocus()
                        end
                        M.just_accepted_aidiff = false
                    end, 500)
                end
                M.warn("accepted aidiff")
            end)
        end)
    end
    M.was_aicoder_focused_when_aidiff_open = M.is_aicoder_focused()
    local tabpages = M.query_tabpages()
    local tabpage_aidiff = tabpages[M.tabt.AIDIFF]
    if tabpage_aidiff == nil then
        -- open new code diff
        vim.cmd.ClaudeCodeOpenCodeDiff()
        return
    end
    M.switch_tab_then(M.tabt.AIDIFF, nil)
end

function M.deny_aidiff()
    -- note we allow denying without the diff open
    -- say we forgot some instruction and want to deny the output
    -- without checking
    local curr_tabpage = vim.api.nvim_get_current_tabpage()
    local is_in_aidiff = M.tabtyp() == M.tabt.AIDIFF
    vim.cmd.ClaudeCodeDiffDeny()
    M.switch_to_editview_then(function()
        vim.cmd(vim.api.nvim_tabpage_get_number(curr_tabpage) .. "tabclose")
        M.switch_to_editview_then(function()
            -- force close the diff buffers
            for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
                if M.buftyp(bufnr) == M.buft.AIDIFF then
                    vim.api.nvim_buf_delete(bufnr, {force=true})
                end
            end
            if is_in_aidiff then
                -- probably want to tell AI what to do differently
                vim.cmd.ClaudeCodeFocus()
            end
            M.warn("denied aidiff")
        end)
    end)
end

---Send context to AI Coder
---@param visual boolean if in visual mode
function M.send_to_aicoder(visual)
    local tt, bt = M.viewtyp()
    if tt ~= M.tabt.EDIT then
        return
    end
    if bt == M.buft.TREE then
        if visual then return end
        -- send file in tree
        vim.cmd.ClaudeCodeTreeAdd()
        vim.cmd.ClaudeCodeFocus()
        return
    end
    if bt ~= M.buft.FILE then
        return
    end
    M.editview_focus_then(function()
        if visual then
            vim.api.nvim_input("gv<cmd>ClaudeCodeSend<cr>")
        else
            vim.cmd("ClaudeCodeAdd %")
        end
        -- keep focus inside fileterm
        vim.defer_fn(function()
            if M.buftyp() ~= M.buft.FILETERM then
                vim.cmd("stopinsert")
                vim.api.nvim_input("<C-w>l")
                vim.cmd("startinsert")
            end
        end, 100)
    end)
end

local git_diff_type = ""

---
function M.open_git_diff(diff_type)
    local tabpages = M.query_tabpages()
    local tabpage_diff = tabpages[M.tabt.DIFF]
    local do_open = function()
        git_diff_type = diff_type
        if diff_type == "status" then
            vim.cmd.CodeDiff()
        else
            -- otherwise it could be:
            -- A..B: diff from commit A to commit B
            -- A: (just the commit/branch name)
            if diff_type:find("%.%.") then
                local a, b = diff_type:match("(.+)%.%.(.+)")
                if a and b then
                    vim.cmd("CodeDiff " .. a .. " " .. b)
                end
            else
                vim.cmd("CodeDiff " .. diff_type)
            end
        end
        -- -- focus on tree
        -- vim.defer_fn(function()
        --     vim.api.nvim_input("<C-w>h<C-w>h")
        -- end, 200)
    end
    if tabpage_diff ~= nil then
        -- if a different diff is opened, close it
        if git_diff_type ~= diff_type then
            vim.api.nvim_command(vim.api.nvim_tabpage_get_number(tabpage_diff).. "tabclose")
            M.switch_to_editview_then(do_open)
        else
            -- otherwise just open that diff
            M.switch_tab_then(M.tabt.DIFF, nil)
        end
        return
    end
    -- no diff opened, just open new one
    M.switch_to_editview_then(do_open)
end

function M.open_file_tree()
    local tt = M.tabtyp()
    if tt == M.tabt.EDIT then
        vim.cmd.NvimTreeOpen()
        return
    end
    if tt == M.tabt.DIFF then
        vim.api.nvim_input("<C-w>h<C-w>h")
        vim.defer_fn(function()
            if M.buftyp() ~= M.buft.DIFFTREE then
                vim.api.nvim_input("<leader>T<C-w>h")
            end
        end, 30)
    end
end

-- PURE ACTIONS ==========================================================================

---Jump to next '_', uppercase letter, or word boundary in the current buffer
---@param action string | nil d for delete and c for change
---@param flag   string | nil flag for the action, "f" or "t" (find or til)
function M.jump_half_word(action, flag)
    -- Save current position
    local row, col = unpack(vim.api.nvim_win_get_cursor(0))
    -- Search pattern: _ or [A-Z] or word boundary (\<)
    local pattern = [[\(_\w\|\u\|\<\)]]
    -- Search forward, no [W]rap and go to [e]nd
    local found = vim.fn.search(pattern, 'We')
    if found == 0 then
        -- Not found, restore cursor
        vim.api.nvim_win_set_cursor(0, {row, col})
        return
    end
    if action == nil then
        return
    end
    if action == 'd' or action == 'c' then
        local new_row, new_col = unpack(vim.api.nvim_win_get_cursor(0))
        vim.api.nvim_win_set_cursor(0, {row, col})
        -- enter visual mode
        vim.cmd('normal! v')
        if flag == 't' then
            vim.api.nvim_win_set_cursor(0, {new_row, new_col - 1})
        else
            vim.api.nvim_win_set_cursor(0, {new_row, new_col})
        end
        vim.cmd('normal! d')
        if action == 'c' then
            vim.cmd('startinsert')
        end
        return
    end
end

---Jump to dianostic
---@param count integer      -1 for previous, 1 for next
---@param error_only boolean filter to only errors
function M.jump_diagnostic(count, error_only)
    if error_only then
        vim.diagnostic.jump({ count = count, severity = vim.diagnostic.severity.ERROR })
    else
        vim.diagnostic.jump({ count = count })
    end
    -- show diagnostic window
    vim.defer_fn(function()
        vim.diagnostic.open_float({ scope = 'cursor' })
    end, 50)
end

-- HELPERS =============================================================================


function M.warn(msg) vim.notify("editorapi: "..msg, vim.log.levels.WARN) end

return M
